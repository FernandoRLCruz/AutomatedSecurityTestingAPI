Revisão bibliográfica Broken Authentcation and Session Management

Authentication

The authentication mechanism is logically the most basic dependency in an application’s handling of user access. Authenticating a user involves establishing that the user is in fact who he claims to be. Without this facility, the application would need to treat all users as anonymous — the lowest possible level of trust.
The majority of today’s web applications employ the conventional authentication model, in which the user submits a username and password, which the application checks for validity. Figure 2-1 shows a typical login function. In security-critical applications such as those used by online banks, this basic model is usually supplemented by additional credentials and a multistage login process. When security requirements are higher still, other authentication models may be used, based on client certifi cates, smartcards, or challenge-response tokens. In addition to the core login process, authentication mechanisms often
employ a range of other supporting functionality, such as self-registration, account recovery, and a password change facility.
Despite their superfi cial simplicity, authentication mechanisms suffer from a wide range of defects in both design and implementation. Common problems may enable an attacker to identify other users’ usernames, guess their passwords, or bypass the login function by exploiting defects in its logic. When you are attacking a web application, you should invest a signifi cant amount of attention to the various authentication-related functions it contains. Surprisingly frequently, defects in this functionality enable you to gain unauthorized access to sensitive data and functionality.

Session Management

The next logical task in the process of handling user access is to manage the authenticated user’s session. After successfully logging in to the application, the user accesses various pages and functions, making a series of HTTP requests from his browser. At the same time, the application receives countless other requests from different users, some of whom are authenticated and some of whom are anonymous. To enforce effective access control, the application needs a way to identify and process the series of requests that originate from each unique user. Virtually all web applications meet this requirement by creating a session for
each user and issuing the user a token that identifi es the session. The session itself is a set of data structures held on the server that track the state of the user’s interaction with the application. The token is a unique string that the application maps to the session. When a user receives a token, the browser automatically submits it back to the server in each subsequent HTTP request, enabling the application to associate the request with that user. HTTP cookies are the standard method for transmitting session tokens, although many applications use hidden form fi elds or the URL query string for this purpose. If a user does not make a request for a certain amount of time, the session is ideally expired. 
In terms of attack surface, the session management mechanism is highly dependent on the security of its tokens. The majority of attacks against it seek to compromise the tokens issued to other users. If this is possible, an attacker can masquerade as the victim user and use the application just as if he had actually authenticated as that user. The principal areas of vulnerability arise from defects in how tokens are generated, enabling an attacker to guess the tokens issued to other users, and defects in how tokens are subsequently handled, enabling an attacker to capture other users’ tokens. A small number of applications dispense with the need for session tokens by using other means of reidentifying users across multiple requests. If HTTP’s built-in authentication mechanism is used, the browser automatically resubmits the user’s credentials with each request, enabling the application to identify the user directly from these. In other cases, the application stores the state information on the client side rather than the server, usually in encrypted form to prevent tampering.





Obs: No framework validar:
->Se a URL está sendo enviada usando https
->Se as credenciais estão sendo enviadas por query string parameter validar se as mesmas estão criptografadas
->Se as credenciais do request estão em texto plano.

Authentication also lies at the heart of an application’s protection against malicious attack. It is the front line of defense against unauthorized access. If an attacker can defeat those defenses, he will often gain full control of the application’s functionality and unrestricted access to the data held within it. Without
robust authentication to rely on, none of the other core security mechanisms (such as session management and access control) can be effective.

Authentication Technologies

A wide range of technologies are available to web application developers when
implementing authentication mechanisms:

->HTML forms-based authentication
->Multifactor mechanisms, such as those combining passwords and physi-
cal tokens
->Client SSL certifi cates and/or smartcards
->HTTP basic and digest authentication
->Windows-integrated authentication using NTLM or Kerberos
->Authentication services

By far the most common authentication mechanism employed by web applications uses HTML forms to capture a username and password and submit these to the application. This mechanism accounts for well over 90% of applications you are likely to encounter on the Internet. Some web applications employ client-side SSL certifi cates or cryptographic mechanisms implemented within smartcards. Because of the overhead of adminis
tering and distributing these items, they are typically used only in security-critical contexts where an application’s user base is small, such as web-based VPNs for remote offi ce workers.
The HTTP-based authentication mechanisms (basic, digest, and Windows integrated) are rarely used on the Internet. Third-party authentication services such as Microsoft Passport are occasion ally encountered, but at the present time they have not been adopted on any significant scale. -> Informção está desatualizada hoje usada em larga escala Microsoft, Google e Facebook.


Design Flaws in Authentication Mechanisms

-Vulnerable Transmission of Credentials

If an application uses an unencrypted HTTP connection to transmit login credentials, an eavesdropper who is suitably positioned on the network can, of course, intercept them. Depending on the user’s location, potential eavesdroppers may reside:

->On the user’s local network
->Within the user’s IT department
->Within the user’s ISP
->On the Internet backbone
->Within the ISP hosting the application
->Within the IT department managing the application


Even if login occurs over HTTPS, credentials may still be disclosed to unauthorized parties if the application handles them in an unsafe manner:

->If credentials are transmitted as query string parameters, as opposed to in the body of a POST request, these are liable to be logged in various places, such as within the user’s browser history, within the web server logs, and within the logs of any reverse proxies employed within the hosting infrastructure. If an attacker succeeds in compromising any of these resources, he may be able to escalate privileges by capturing the user credentials stored there.

->Web applications sometimes store user credentials in cookies, usually to implement poorly designed mechanisms for login, password change, “remember me,” and so on. These credentials are vulnerable to capture via attacks that compromise user cookies and, in the case of persistent cookies, by anyone who gains access to the client’s local fi lesystem. Even if
the credentials are encrypted, an attacker still can simply replay the cookie and therefore log in as a user without actually knowing her credentials.


-Password Change Functionality

Although it is a necessary part of an effective authentication mechanism, password change functionality is often vulnerable by design. Vulnerabilities that are deliberately avoided in the main login function often reappear in the password change function. Many web applications’ password change functions are accessible without authentication and do the following:
  
  -> Provide a verbose error message indicating whether the requested username is valid.
  -> Allow unrestricted guesses of the “existing password” field.
  -> Check whether the “new password” and “confi rm new password” fields have the same value only after validating the existing password, thereby allowing an attack to succeed in discovering the existing password noninvasively.
  
A typical password change function includes a relatively large logical decision tree. The application needs to identify the user, validate the supplied existing password, integrate with any account lockout defenses, compare the supplied new passwords with each other and against password quality rules, and feed back any error conditions to the user in a suitable way. Because of this, password change functions often contain subtle logic fl aws that can be exploited to subvert the entire mechanism.  













